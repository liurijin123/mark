## 四种隔离级别

1、Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。

2、Repeatable read (可重复读)：可避免脏读、不可重复读的发生。

3、Read committed (读已提交)：可避免脏读的发生。

4、Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

## 脏读（读取未提交数据）
>A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。

时间顺序|转账事务|取款事务
---|---|---
1 | |开始事务
2 |开始事务|
3 | |查询账户余额为2000元
4 | |取款1000元，余额被更改为1000元
5 | |查询账户余额为1000元（产生脏读）
6 | |取款操作发生未知错误，事务回滚，余额变更为2000元
7 |转入2000元，余额被更改为3000元（脏读的1000+2000）|
8 |提交事务|

## 不可重复读（前后多次读取，数据内容不一致）
>事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。

时间顺序|转账事务|取款事务
---|---|---
1 |开始事务| 
2 |第一次查询，小明的年龄为20岁|
3 | |开始事务
4 |其他操作|
5 | |更改小明的年龄为30岁
6 | |提交事务
7 |第二次查询，小明的年龄为30岁|
## 幻读（前后多次读取，数据总量不一致）
>事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。

时间顺序|转账事务|取款事务
---|---|---
1 |开始事务|
2 |第一次查询，数据总量为100条|
3 | |开始事务
4 |其他操作|
5 | |新增100条数据
6 | |提交事务
7 |第二次查询，数据总量为200条|
## 不可重复读和幻读到底有什么区别呢？
（1）不可重复读是读取了其他事务更改的数据，针对update操作

解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

（2）幻读是读取了其他事务新增的数据，针对insert操作

解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。

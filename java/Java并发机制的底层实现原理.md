## 一、Java对象头
synchronized用的锁是存在Java对象头里的，如果对象是数组类型，则虚拟机用3个字宽(Word)存储对象头，如果是非数组类型，则用2字宽存储对象头。在32位虚拟机中
1字宽等于4字节，即32bit

Java对象头长度

长度|内容|说明
---|---|---
32/64bit|Mark Word|存储对象的hashCode或锁信息
32/64bit|Class Mwtadata Address|存储到对象类型数据的指针
32/64bit|Array length|数组的长度

32位虚拟机在不同状态下markword结构如下图所示

![](http://m.qpic.cn/psb?/V12X9A3m33wlIQ/gC8TOWegaWUScg.WZMCuce1ZZKDeIt1H.oAksycV5P0!/b/dFcAAAAAAAAA&bo=nQMvAZ0DLwEDCSw!&rf=viewer_4)

## 二、锁的四种状态
### 1.无锁状态
### 2.偏向锁
+ 偏向锁初始化：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入偏向锁。当一个线程访问同步快并获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得锁。如果测试失败，则需在测试一下Mark Word中偏向锁的标识是否设置成1(表示当前是偏向锁)：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
+ 偏向锁撤销：偏向锁使用一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销需要等代全局安全点(在这个时间点上没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将锁设置成无锁状态；如果线程仍热活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁状态或标记对象不适合作为偏向锁，最后唤醒暂停的线程。
+ 关闭偏向锁：偏向锁在Java6和Java7中默认开启，但是他在应用程序启动几秒钟后才激活，如果有必要可以使用JVM来关闭延迟：-XX:BiasedLockingStartupDelay=0。
也可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false,那么程序默认进入轻量级锁状态
### 3.轻量级锁
### 4.重量级锁

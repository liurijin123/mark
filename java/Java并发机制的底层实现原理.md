## 一、Java对象头
synchronized用的锁是存在Java对象头里的，如果对象是数组类型，则虚拟机用3个字宽(Word)存储对象头，如果是非数组类型，则用2字宽存储对象头。在32位虚拟机中
1字宽等于4字节，即32bit

Java对象头长度

长度|内容|说明
---|---|---
32/64bit|Mark Word|存储对象的hashCode或锁信息
32/64bit|Class Mwtadata Address|存储到对象类型数据的指针
32/64bit|Array length|数组的长度

32位虚拟机在不同状态下markword结构如下图所示

![](http://m.qpic.cn/psb?/V12X9A3m33wlIQ/gC8TOWegaWUScg.WZMCuce1ZZKDeIt1H.oAksycV5P0!/b/dFcAAAAAAAAA&bo=nQMvAZ0DLwEDCSw!&rf=viewer_4)

## 二、锁的四种状态
+ 偏向锁：仅有一个线程进入临界区
+ 轻量级锁：多个线程交替进入临界区
+ 重量级锁：多个线程同时进入临界区
### 1.无锁状态
### 2.偏向锁
+ 偏向锁初始化：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入偏向锁。当一个线程访问同步快并获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得锁。如果测试失败，则需在测试一下Mark Word中偏向锁的标识是否设置成1(表示当前是偏向锁)：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
+ 偏向锁撤销：偏向锁使用一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销需要等代全局安全点(在这个时间点上没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将锁设置成无锁状态；如果线程仍热活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁状态或标记对象不适合作为偏向锁(升级为轻量级锁)，最后唤醒暂停的线程。
+ 关闭偏向锁：偏向锁在Java6和Java7中默认开启，但是他在应用程序启动几秒钟后才激活，如果有必要可以使用JVM来关闭延迟：-XX:BiasedLockingStartupDelay=0。
也可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false,那么程序默认进入轻量级锁状态
### 3.轻量级锁
锁撤销升级为轻量级锁之后，那么对象的Markword也会进行相应的的变化。下面先简单描述下锁撤销之后，升级为轻量级锁的过程：

线程在自己的栈桢中创建锁记录 LockRecord。

将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。

将锁记录中的Owner指针指向锁对象。
![](http://m.qpic.cn/psb?/V12X9A3m33wlIQ/e4wSm4oYf*sJS2H6sEky4Cme2Ia4YAnELQg3zSJfjvg!/b/dFMBAAAAAAAA&bo=0QJYAdECWAEDCSw!&rf=viewer_4)
![](http://m.qpic.cn/psb?/V12X9A3m33wlIQ/ZiFvdlZ4yGmcaK.VmlXTwS3ZudhLDcIwUBXvVS56IVY!/b/dEkBAAAAAAAA&bo=JQJXASUCVwEDCSw!&rf=viewer_4)
将锁对象的对象头的MarkWord替换为指向锁记录的指针。
轻量级锁主要有两种
+ 自旋锁
+ 自适应自旋锁

**自旋锁** 

所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。

注意，锁在原地循环的时候，是会消耗cpu的，就相当于在执行一个啥也没有的for循环。

所以，轻量级锁适用于那些同步代码块执行的很快的场景，这样，线程原地等待很短很短的时间就能够获得锁了。

经验表明，大部分同步代码块执行的时间都是很短很短的，也正是基于这个原因，才有了轻量级锁这么个东西。

自旋锁的一些问题:

如果同步代码块执行的很慢，需要消耗大量的时间，那么这个时侯，其他线程在原地等待空消耗cpu。

本来一个线程把锁释放之后，当前线程是能够获得锁的，但是假如这个时候有好几个线程都在竞争这个锁的话，那么有可能当前线程会获取不到锁，还得原地等待继续空循环消耗cup，甚至有可能一直获取不到锁。

基于这个问题，我们必须给线程空循环设置一个次数，当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。

默认情况下，自旋的次数为10次，用户可以通过-XX:PreBlockSpin来进行更改。
**自适应自旋锁**
所谓自适应自旋锁就是线程空循环等待的自旋次数并非是固定的，而是会动态着根据实际情况来改变自旋等待的次数。

其大概原理是这样的：

假如一个线程1刚刚成功获得一个锁，当它把锁释放了之后，线程2获得该锁，并且线程2在运行的过程中，此时线程1又想来获得该锁了，但线程2还没有释放该锁，所以线程1只能自旋等待，但是虚拟机认为，由于线程1刚刚获得过该锁，那么虚拟机觉得线程1这次自旋也是很有可能能够再次成功获得该锁的，所以会延长线程1自旋的次数。
另外，如果对于某一个锁，一个线程自旋之后，很少成功获得该锁，那么以后这个线程要获取该锁时，是有可能直接忽略掉自旋过程，直接升级为重量级锁的，以免空循环等待浪费资源。

>轻量级锁也被称为非阻塞同步、乐观锁，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。
### 4.重量级锁
轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。

**为什么说重量级锁开销大呢**
主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。
这就是说为什么重量级线程开销很大的。

>互斥锁(重量级锁)也称为阻塞同步、悲观锁
## 总结
![](http://r.photo.store.qq.com/psb?/V12X9A3m33wlIQ/q1M*CqvfhHB9aYG9tQ3U0OuVcGWQgYEHCI3iYD0rbd0!/r/dDEBAAAAAAAA)

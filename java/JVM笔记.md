## JVM 参数配置 -Xms -Xmx -Xmn -Xss 
### -Xmx:
设置JVM最大可用内存.

### -Xms:
设置JVM初始内存.此值可以设置与-Xmx相同,以避免每次垃圾回收完成后JVM重新分配内存.

### -Xmn:
设置年轻代大小.整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.持久代一般固定大小为64m,所以增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8.

### -Xss:
设置每个线程的堆栈大小.
## java内存区域
### 程序计数器（线程隔离的数据区）
程序计数器是一块较小的内存空间，他的作用可以看作是当前线程所执行的字节码的行号指示器。

由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行
一条线程中的指令。因此，**为了线程切换后能恢复到正确的执行位置** ，每条线程都要有独立的程序技术器，各条线程之间的计数器互不影响，独立存储。

### 虚拟机栈（线程隔离的数据区）
虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行是时候都会同时创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。

局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令的地址）

每一个方法被调用直至执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程

### 本地方法栈（线程隔离的数据区）
本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。

### 方法区（所有线程共享的数据区）
方法区又叫静态区，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### 堆（所有线程共享的数据区）
Java堆唯一的目的就是存放对象实例，几乎所有的对象（包括数组）都在这里分配内存

如果从内存回收的角度看，由于现在收集器基本采用分代收集算法，所以Java堆可以细分为：新生代和老年代；在细致一点还有Eden空间、Survivor空间。

## 内存溢出异常
### Java堆溢出
### 虚拟机栈和本地方法栈溢出
### 运行时常量池溢出
### 方法区溢出
### 本机直接内存溢出

## 垃圾收集器与内存分配策略
### 确定对象是否可回收
**1、引用计数法：** 给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器都为0的对象就是
不可能在被使用的。

**2、根搜索算法：** 通过一系列的名为“GC Roots”的对象作为起始点。从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引
用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的
### 垃圾收集算法
**1、标记-清除算法：** 首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它的缺点主要有两个：一个是效率问题，标记和清除过程效率
都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片。

**2、复制算法：** 将可用内存按容量大小分为大小相等的两块，每次只使用其中一块。当一块内容用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用
过的内存空间一次清理掉。这样使得每次都是对其中一块进行内存回收，内存分配是也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。只是
这种算法的代价是将内存缩小为原来的一半。

**3、复制算法优化：** 由于新生代中的对象98%都是朝生夕死，所以可以将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor的空间。

**4、标记-整理算法：** 标记过程与“标记-清除算法”一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界
意外的内存。

## 虚拟机性能监控与故障处理工具

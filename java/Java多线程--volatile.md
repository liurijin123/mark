一个被volatile声明的变量主要有以下两种特性保证保证线程安全。
+ 可见性。
+ 有序性。
## 一、可见性
### 1.什么是可见性？
意思就是说，在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，
最终会去内存中读取，而不是从自己的工作空间中读取。

假如一个变量被声明为volatile，那么这个变量就具有了可见性的性质了。这就是volatile关键的作用之一了。
### 2.volatile保证变量可见性的原理
当一个变量被声明为volatile时，在编译成会变指令的时候，会多出下面一行：
```
0x00bbacde: lock add1 $0x0,(%esp);
```
这句指令的意思就是在寄存器执行一个加0的空操作。不过这条指令的前面有一个lock(锁)前缀。
当处理器在处理拥有lock前缀的指令时：在之前的处理中，lock会导致传输数据的总线被锁定，其他处理器都不能访问总线，从而保证处理lock指令的处理器能够独享操作数据所在的内存区域，而不会被其他处
理所干扰。但由于总线被锁住，其他处理器都会被堵住，从而影响了多处理器的执行效率。为了解决这个问题，在后来的处理器中，处理器遇到lock指令时
不会再锁住总线，而是会检查数据所在的内存区域，如果该数据是在处理器的内部缓存中，则会锁定此缓存区域，处理完后把缓存写回到主存中，并且会利用缓存一致性
协议来保证其他处理器中的缓存数据的一致性。
### 3.缓存一致性协议
线程中的处理器会一直在总线上嗅探其内部缓存中的内存地址在其他处理器的操作情况，一旦嗅探到某处处理器打算修改其内存地址中的值，
而该内存地址刚好也在自己的内部缓存中，那么处理器就会强制让自己对该缓存地址的无效。所以当该处理器要访问该数据的时候，由于发现自己缓存的数据无效了，
就会去主存中访问。
## 二、有序性
虚拟机在进行代码编译优化的时候，对于那些改变顺序之后不会对最终变量的值造成影响的代码，是有可能将他们进行重排序的。对于有些代码进行重排序之后，
虽然对变量的值没有造成影响，但有可能会出现线程安全问题，如果一个变量被声明volatile的话，那么这个变量不会被进行重排序，也就是说，虚拟机会保证这个
变量之前的代码一定会比它先执行，而之后的代码一定会比它慢执行。
## 三、volatile真的能完全保证一个变量的线程安全吗？
我们通过上面的讲解，发现volatile关键字还是挺有用的，不但能够保证变量的可见性，还能保证代码的有序性。
那么，它真的能够保证一个变量在多线程环境下都能被正确的使用吗？
答案是否定的。原因是因为Java里面的运算并非是原子操作。
## 四、什么情况下volatile能够保证线程安全
刚才虽然说，volatile关键字不一定能够保证线程安全的问题，其实，在大多数情况下volatile还是可以保证变量的线程安全问题的。所以，
在满足以下两个条件的情况下，volatile就能保证变量的线程安全问题：
+ 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
+ 变量不需要与其他状态变量共同参与不变约束。
